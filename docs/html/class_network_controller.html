<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Programming Project I DA: NetworkController Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Programming Project I DA
   </div>
   <div id="projectbrief">An Analysis Tool for Water Supply Management</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_network_controller-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">NetworkController Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a068bf0e71bb060d53c8c2a13abd90136" id="r_a068bf0e71bb060d53c8c2a13abd90136"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a068bf0e71bb060d53c8c2a13abd90136">NetworkController</a> (const std::string &amp;src)</td></tr>
<tr class="memdesc:a068bf0e71bb060d53c8c2a13abd90136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="class_network_controller.html">NetworkController</a> class.  <br /></td></tr>
<tr class="separator:a068bf0e71bb060d53c8c2a13abd90136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911d450474ee64e37936ba17189db583" id="r_a911d450474ee64e37936ba17189db583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a911d450474ee64e37936ba17189db583">parseData</a> ()</td></tr>
<tr class="memdesc:a911d450474ee64e37936ba17189db583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses data from files to initialize the network graph.  <br /></td></tr>
<tr class="separator:a911d450474ee64e37936ba17189db583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2016e06885a75757fe09ad5d4109580b" id="r_a2016e06885a75757fe09ad5d4109580b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2016e06885a75757fe09ad5d4109580b">parseDataSmall</a> ()</td></tr>
<tr class="memdesc:a2016e06885a75757fe09ad5d4109580b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a small amount of data from files to initialize the network graph.  <br /></td></tr>
<tr class="separator:a2016e06885a75757fe09ad5d4109580b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af107057d276b2b6b33493a0909761725" id="r_af107057d276b2b6b33493a0909761725"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af107057d276b2b6b33493a0909761725">readReservoirs</a> ()</td></tr>
<tr class="memdesc:af107057d276b2b6b33493a0909761725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads reservoir data from files and adds reservoir vertices to the graph.  <br /></td></tr>
<tr class="separator:af107057d276b2b6b33493a0909761725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91437811c29e05a2e1c852cd8d7d79c" id="r_ad91437811c29e05a2e1c852cd8d7d79c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad91437811c29e05a2e1c852cd8d7d79c">readReservoirsSmall</a> ()</td></tr>
<tr class="memdesc:ad91437811c29e05a2e1c852cd8d7d79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a small amount of reservoir data from files and adds reservoir vertices to the graph.  <br /></td></tr>
<tr class="separator:ad91437811c29e05a2e1c852cd8d7d79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271abf1a9f0fb19db8a034c1a66d3178" id="r_a271abf1a9f0fb19db8a034c1a66d3178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a271abf1a9f0fb19db8a034c1a66d3178">readPumpingStations</a> ()</td></tr>
<tr class="memdesc:a271abf1a9f0fb19db8a034c1a66d3178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads pumping station data from files and adds pumping station vertices to the graph.  <br /></td></tr>
<tr class="separator:a271abf1a9f0fb19db8a034c1a66d3178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd6bcc261d916c0ba1ffd681f36c416" id="r_afcd6bcc261d916c0ba1ffd681f36c416"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcd6bcc261d916c0ba1ffd681f36c416">readStationsSmall</a> ()</td></tr>
<tr class="memdesc:afcd6bcc261d916c0ba1ffd681f36c416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a small amount of pumping station data from files and adds pumping station vertices to the graph.  <br /></td></tr>
<tr class="separator:afcd6bcc261d916c0ba1ffd681f36c416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5274e2d7054a384189406332ed8fc302" id="r_a5274e2d7054a384189406332ed8fc302"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5274e2d7054a384189406332ed8fc302">readCities</a> ()</td></tr>
<tr class="memdesc:a5274e2d7054a384189406332ed8fc302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads city data from files and adds city vertices to the graph.  <br /></td></tr>
<tr class="separator:a5274e2d7054a384189406332ed8fc302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5990ce7ee9d7d954fc930ac25928b487" id="r_a5990ce7ee9d7d954fc930ac25928b487"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5990ce7ee9d7d954fc930ac25928b487">readCitiesSmall</a> ()</td></tr>
<tr class="memdesc:a5990ce7ee9d7d954fc930ac25928b487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a small amount of city data from files and adds city vertices to the graph.  <br /></td></tr>
<tr class="separator:a5990ce7ee9d7d954fc930ac25928b487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e9b3e10e489a2716b8174d9772013f" id="r_a20e9b3e10e489a2716b8174d9772013f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20e9b3e10e489a2716b8174d9772013f">readPipes</a> ()</td></tr>
<tr class="memdesc:a20e9b3e10e489a2716b8174d9772013f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads pipe data from files and adds pipes to connect vertices in the graph.  <br /></td></tr>
<tr class="separator:a20e9b3e10e489a2716b8174d9772013f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af704aebfe404fc5430d2074ab15682fb" id="r_af704aebfe404fc5430d2074ab15682fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af704aebfe404fc5430d2074ab15682fb">readPipesSmall</a> ()</td></tr>
<tr class="memdesc:af704aebfe404fc5430d2074ab15682fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a small amount of pipe data from files and adds pipes to connect vertices in the graph.  <br /></td></tr>
<tr class="separator:af704aebfe404fc5430d2074ab15682fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd67674c6fe7831a02ddebed6ef0962e" id="r_afd67674c6fe7831a02ddebed6ef0962e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd67674c6fe7831a02ddebed6ef0962e">initializeNetwork</a> (bool small)</td></tr>
<tr class="memdesc:afd67674c6fe7831a02ddebed6ef0962e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the network graph.  <br /></td></tr>
<tr class="separator:afd67674c6fe7831a02ddebed6ef0962e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ae5fa84350cc8214624b57512c4594" id="r_aa2ae5fa84350cc8214624b57512c4594"><td class="memItemLeft" align="right" valign="top"><a id="aa2ae5fa84350cc8214624b57512c4594" name="aa2ae5fa84350cc8214624b57512c4594"></a>
std::unordered_map&lt; std::string, std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simulatePipelineFailure</b> (const std::string &amp;servicePointA, const std::string &amp;servicePointB)</td></tr>
<tr class="memdesc:aa2ae5fa84350cc8214624b57512c4594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulates the failure of a pipeline and evaluates its impact on the network flow. @complexity O(V*E^2), due to the necessity to rerun the Edmonds-Karp algorithm after modifying the network. <br /></td></tr>
<tr class="separator:aa2ae5fa84350cc8214624b57512c4594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0ce2712cedbe4d9d65c92bc699c4ff" id="r_a0d0ce2712cedbe4d9d65c92bc699c4ff"><td class="memItemLeft" align="right" valign="top"><a id="a0d0ce2712cedbe4d9d65c92bc699c4ff" name="a0d0ce2712cedbe4d9d65c92bc699c4ff"></a>
<a class="el" href="class_pipe.html">Pipe</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>findPipe</b> (const std::string &amp;servicePointA, const std::string &amp;servicePointB)</td></tr>
<tr class="memdesc:a0d0ce2712cedbe4d9d65c92bc699c4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a pipe between two service points. @complexity O(1), assuming a hash map or similar data structure is used for efficient lookup. <br /></td></tr>
<tr class="separator:a0d0ce2712cedbe4d9d65c92bc699c4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b233f36990e2cba20af91739ab4188b" id="r_a5b233f36990e2cba20af91739ab4188b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b233f36990e2cba20af91739ab4188b">getVertex</a> (const std::string &amp;id)</td></tr>
<tr class="memdesc:a5b233f36990e2cba20af91739ab4188b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a vertex from the graph by its identifier.  <br /></td></tr>
<tr class="separator:a5b233f36990e2cba20af91739ab4188b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46761ae0837190c2cc46a3a89fb3de7" id="r_af46761ae0837190c2cc46a3a89fb3de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af46761ae0837190c2cc46a3a89fb3de7">getSuperSource</a> ()</td></tr>
<tr class="memdesc:af46761ae0837190c2cc46a3a89fb3de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a super source vertex that connects all sources to it with edge capacity INF.  <br /></td></tr>
<tr class="separator:af46761ae0837190c2cc46a3a89fb3de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9517ce860591b3c2e6453dfa282b55b2" id="r_a9517ce860591b3c2e6453dfa282b55b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9517ce860591b3c2e6453dfa282b55b2">getSuperSink</a> ()</td></tr>
<tr class="memdesc:a9517ce860591b3c2e6453dfa282b55b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a super sink vertex that connects all sinks to it with edge capacity INF.  <br /></td></tr>
<tr class="separator:a9517ce860591b3c2e6453dfa282b55b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d082e6749a1628fe78a774be3109329" id="r_a8d082e6749a1628fe78a774be3109329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d082e6749a1628fe78a774be3109329">edmondsKarp</a> ()</td></tr>
<tr class="memdesc:a8d082e6749a1628fe78a774be3109329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Edmonds-Karp algorithm to find the maximum flow in the network.  <br /></td></tr>
<tr class="separator:a8d082e6749a1628fe78a774be3109329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec6f22070d9d3950ed5e5b17815926e" id="r_a9ec6f22070d9d3950ed5e5b17815926e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ec6f22070d9d3950ed5e5b17815926e">findAugmentingPath</a> (<a class="el" href="class_vertex.html">Vertex</a> *source, <a class="el" href="class_vertex.html">Vertex</a> *sink)</td></tr>
<tr class="memdesc:a9ec6f22070d9d3950ed5e5b17815926e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an augmenting path from the source to the sink using BFS.  <br /></td></tr>
<tr class="separator:a9ec6f22070d9d3950ed5e5b17815926e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e11da8f5a2b362d8d5b6a49871971f" id="r_a76e11da8f5a2b362d8d5b6a49871971f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76e11da8f5a2b362d8d5b6a49871971f">testAndVisit</a> (std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;, <a class="el" href="class_pipe.html">Pipe</a> *pipe, <a class="el" href="class_vertex.html">Vertex</a> *dest, double residual)</td></tr>
<tr class="memdesc:a76e11da8f5a2b362d8d5b6a49871971f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests and visits vertices along a path to determine the residual flow.  <br /></td></tr>
<tr class="separator:a76e11da8f5a2b362d8d5b6a49871971f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee357be4a30bcfe5d1ce2b6f254a73ff" id="r_aee357be4a30bcfe5d1ce2b6f254a73ff"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee357be4a30bcfe5d1ce2b6f254a73ff">findMinResidualAlongPath</a> (<a class="el" href="class_vertex.html">Vertex</a> *source, <a class="el" href="class_vertex.html">Vertex</a> *sink)</td></tr>
<tr class="memdesc:aee357be4a30bcfe5d1ce2b6f254a73ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum residual along a path between a source and a sink.  <br /></td></tr>
<tr class="separator:aee357be4a30bcfe5d1ce2b6f254a73ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb89054db645551ff46918917041dcb9" id="r_adb89054db645551ff46918917041dcb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb89054db645551ff46918917041dcb9">augmentFlowAlongPath</a> (<a class="el" href="class_vertex.html">Vertex</a> *source, <a class="el" href="class_vertex.html">Vertex</a> *sink, double f)</td></tr>
<tr class="memdesc:adb89054db645551ff46918917041dcb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augments the flow along the found augmenting path.  <br /></td></tr>
<tr class="separator:adb89054db645551ff46918917041dcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ad70cc28b7ef6b670641f247bcd054" id="r_ad3ad70cc28b7ef6b670641f247bcd054"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3ad70cc28b7ef6b670641f247bcd054">getLowWaterCities</a> ()</td></tr>
<tr class="memdesc:ad3ad70cc28b7ef6b670641f247bcd054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves cities with low water levels.  <br /></td></tr>
<tr class="separator:ad3ad70cc28b7ef6b670641f247bcd054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9e4151c670ce849efcdcb0c7c0aab4" id="r_a5b9e4151c670ce849efcdcb0c7c0aab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b9e4151c670ce849efcdcb0c7c0aab4">saveCityData</a> ()</td></tr>
<tr class="memdesc:a5b9e4151c670ce849efcdcb0c7c0aab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves city data to files.  <br /></td></tr>
<tr class="separator:a5b9e4151c670ce849efcdcb0c7c0aab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327c30181704d49b267a841c47ba1724" id="r_a327c30181704d49b267a841c47ba1724"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a327c30181704d49b267a841c47ba1724">getMaxFlowInCity</a> (const std::string &amp;city)</td></tr>
<tr class="memdesc:a327c30181704d49b267a841c47ba1724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the maximum flow in a city.  <br /></td></tr>
<tr class="separator:a327c30181704d49b267a841c47ba1724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e30d9415f43e2e3dcc656f98ef7d757" id="r_a9e30d9415f43e2e3dcc656f98ef7d757"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e30d9415f43e2e3dcc656f98ef7d757">getNetworkFlow</a> ()</td></tr>
<tr class="memdesc:a9e30d9415f43e2e3dcc656f98ef7d757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the network flow.  <br /></td></tr>
<tr class="separator:a9e30d9415f43e2e3dcc656f98ef7d757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0520ebbd3516cacbf856e9fdc156f5a6" id="r_a0520ebbd3516cacbf856e9fdc156f5a6"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0520ebbd3516cacbf856e9fdc156f5a6">getAffectedByReservoir</a> (const std::string &amp;res_id)</td></tr>
<tr class="memdesc:a0520ebbd3516cacbf856e9fdc156f5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves vertices affected by a reservoir.  <br /></td></tr>
<tr class="separator:a0520ebbd3516cacbf856e9fdc156f5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c71ec8fd92b5233b51448f852092c14" id="r_a5c71ec8fd92b5233b51448f852092c14"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c71ec8fd92b5233b51448f852092c14">getAffectedByStation</a> (const std::string &amp;res_id)</td></tr>
<tr class="memdesc:a5c71ec8fd92b5233b51448f852092c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves vertices affected by a pumping station.  <br /></td></tr>
<tr class="separator:a5c71ec8fd92b5233b51448f852092c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4679e5aa16920742f8e1a986bc5277c" id="r_af4679e5aa16920742f8e1a986bc5277c"><td class="memItemLeft" align="right" valign="top"><a id="af4679e5aa16920742f8e1a986bc5277c" name="af4679e5aa16920742f8e1a986bc5277c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>balanceNetwork</b> ()</td></tr>
<tr class="memdesc:af4679e5aa16920742f8e1a986bc5277c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balances the network to achieve more uniform flow distribution. @complexity O(V*E^2), assuming adjustment of capacities and rerunning of Edmonds-Karp to assess the impact. <br /></td></tr>
<tr class="separator:af4679e5aa16920742f8e1a986bc5277c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:adde3b04107475aabb34b0dbaffc01dd3" id="r_adde3b04107475aabb34b0dbaffc01dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adde3b04107475aabb34b0dbaffc01dd3">network</a></td></tr>
<tr class="separator:adde3b04107475aabb34b0dbaffc01dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5168629871a52c482123004704a4384" id="r_ac5168629871a52c482123004704a4384"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5168629871a52c482123004704a4384">dataRoot</a></td></tr>
<tr class="separator:ac5168629871a52c482123004704a4384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27713d324f3e08d08ccf7ad6ef3d9142" id="r_a27713d324f3e08d08ccf7ad6ef3d9142"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27713d324f3e08d08ccf7ad6ef3d9142">maxFlowValid</a></td></tr>
<tr class="separator:a27713d324f3e08d08ccf7ad6ef3d9142"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a068bf0e71bb060d53c8c2a13abd90136" name="a068bf0e71bb060d53c8c2a13abd90136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068bf0e71bb060d53c8c2a13abd90136">&#9670;&#160;</a></span>NetworkController()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NetworkController::NetworkController </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for <a class="el" href="class_network_controller.html">NetworkController</a> class. </p>
<p>Initializes the dataRoot attribute with the provided source string, which represents the root directory of the data. It also sets the maxFlowValid attribute to false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The root directory containing data files. @complexity O(1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adb89054db645551ff46918917041dcb9" name="adb89054db645551ff46918917041dcb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb89054db645551ff46918917041dcb9">&#9670;&#160;</a></span>augmentFlowAlongPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::augmentFlowAlongPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>sink</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Augments the flow along the found augmenting path. </p>
<p>This method iterates over the path stored in the vertices from the sink to the source and updates the flow in each edge along the path by the minimum residual capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The starting vertex of the augmenting path. </td></tr>
    <tr><td class="paramname">sink</td><td>The ending vertex of the augmenting path. </td></tr>
    <tr><td class="paramname">f</td><td>The amount of flow to augment along the path.</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity O(P), where P is the number of edges in the augmenting path. </p>

</div>
</div>
<a id="a8d082e6749a1628fe78a774be3109329" name="a8d082e6749a1628fe78a774be3109329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d082e6749a1628fe78a774be3109329">&#9670;&#160;</a></span>edmondsKarp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::edmondsKarp </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements the Edmonds-Karp algorithm to find the maximum flow in the network. </p>
<p>This function generates a super source and a super sink, initializes flow values, and then iteratively finds augmenting paths and augments flow along them. It uses BFS to find the shortest path in terms of the number of edges, ensuring polynomial time complexity.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Assumes that the graph has been properly initialized with vertices and edges. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The graph will contain flow values corresponding to the maximum flow from source to sink.</dd></dl>
<p>@complexity O(V * E^2), where V is the number of vertices and E is the number of edges in the graph. </p>

</div>
</div>
<a id="a9ec6f22070d9d3950ed5e5b17815926e" name="a9ec6f22070d9d3950ed5e5b17815926e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec6f22070d9d3950ed5e5b17815926e">&#9670;&#160;</a></span>findAugmentingPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool NetworkController::findAugmentingPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>sink</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an augmenting path from the source to the sink using BFS. </p>
<p>An augmenting path is a path where the residual capacity (original capacity minus current flow) is greater than zero. The path is stored in each vertex's 'path' field by the BFS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The starting vertex for the BFS. </td></tr>
    <tr><td class="paramname">sink</td><td>The target vertex for the BFS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an augmenting path is found, false otherwise.</dd></dl>
<p>@complexity O(E), where E is the number of edges in the graph since BFS traverses each edge at most once. </p>

</div>
</div>
<a id="aee357be4a30bcfe5d1ce2b6f254a73ff" name="aee357be4a30bcfe5d1ce2b6f254a73ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee357be4a30bcfe5d1ce2b6f254a73ff">&#9670;&#160;</a></span>findMinResidualAlongPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double NetworkController::findMinResidualAlongPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>sink</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the minimum residual along a path between a source and a sink. </p>
<p>Calculates the minimum residual capacity along the augmenting path found during the Edmonds-Karp algorithm. It iterates through the path from the sink to the source, determining the minimum residual capacity based on the capacities and flows of the pipes along the path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source vertex. </td></tr>
    <tr><td class="paramname">sink</td><td>The sink vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum residual along the path. @complexity O(P), where P is the length of the path. </dd></dl>

</div>
</div>
<a id="a0520ebbd3516cacbf856e9fdc156f5a6" name="a0520ebbd3516cacbf856e9fdc156f5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0520ebbd3516cacbf856e9fdc156f5a6">&#9670;&#160;</a></span>getAffectedByReservoir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, std::pair&lt; double, double &gt; &gt; NetworkController::getAffectedByReservoir </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>res_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves vertices affected by a reservoir. </p>
<p>Analyzes the impact of removing a reservoir on city flows. It locates the reservoir in the network and retrieves the initial flow values before removal. Then, it sets the reservoir's outgoing pipes' capacities to 0, recalculates the flows, and compares the before-and-after values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res_id</td><td>The identifier of the reservoir. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unordered map containing vertex codes and their respective minimum and maximum flow values. @complexity O(V*E^2), due to the necessity to rerun the Edmonds-Karp algorithm after modifying the network. </dd></dl>

</div>
</div>
<a id="a5c71ec8fd92b5233b51448f852092c14" name="a5c71ec8fd92b5233b51448f852092c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c71ec8fd92b5233b51448f852092c14">&#9670;&#160;</a></span>getAffectedByStation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, std::pair&lt; double, double &gt; &gt; NetworkController::getAffectedByStation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>res_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves vertices affected by a pumping station. </p>
<p>Examines the impact of removing a pumping station on city flows. It first locates the station in the network and retrieves the initial flow values before removal. Then, it temporarily removes the station's incoming and outgoing pipes, recalculates the flows, and compares the before-and-after values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res_id</td><td>The identifier of the pumping station. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An unordered map containing vertex codes and their respective minimum and maximum flow values. @complexity O(V*E^2), because of the need to rerun the Edmonds-Karp algorithm after network modification. </dd></dl>

</div>
</div>
<a id="ad3ad70cc28b7ef6b670641f247bcd054" name="ad3ad70cc28b7ef6b670641f247bcd054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ad70cc28b7ef6b670641f247bcd054">&#9670;&#160;</a></span>getLowWaterCities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, double &gt; &gt; NetworkController::getLowWaterCities </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves cities with low water levels. </p>
<p>Identifies cities experiencing water shortage by comparing their demand with the current flow distribution after running the Edmonds-Karp algorithm. It retrieves the super sink vertex and checks incoming pipes. For cities with demand exceeding flow, it records the shortfall.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs containing city codes and their respective water levels. @complexity O(C), where C is the number of cities connected to the super sink. The complexity is linear with respect to the number of cities because the method iterates once through all the incoming pipes to the super sink, each representing a city's water supply. </dd></dl>

</div>
</div>
<a id="a327c30181704d49b267a841c47ba1724" name="a327c30181704d49b267a841c47ba1724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327c30181704d49b267a841c47ba1724">&#9670;&#160;</a></span>getMaxFlowInCity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::string, double &gt; NetworkController::getMaxFlowInCity </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>city</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the maximum flow in a city. </p>
<p>Calculates the maximum flow reaching a given city within the network. It first ensures the network's maximum flow values are up-to-date by invoking edmondsKarp. Then, it retrieves the city vertex. If the city doesn't exist, it returns a pair with the city name and -1. Otherwise, it checks outgoing pipes from the city to find the flow to the super sink.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">city</td><td>The code of the city. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing the city code and its maximum flow. @complexity O(1) assuming the flow values are already calculated and O(V*E^2) if Edmonds-Karp needs to be run. </dd></dl>

</div>
</div>
<a id="a9e30d9415f43e2e3dcc656f98ef7d757" name="a9e30d9415f43e2e3dcc656f98ef7d757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e30d9415f43e2e3dcc656f98ef7d757">&#9670;&#160;</a></span>getNetworkFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, double &gt; NetworkController::getNetworkFlow </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the network flow. </p>
<p>Obtains the flow values for cities within the network. It first verifies the validity of the maximum flow values using edmondsKarp if necessary. Then, it retrieves the super sink vertex. It iterates over incoming pipes to the super sink, collecting flow values for cities and storing them in an unordered map.</p>
<dl class="section return"><dt>Returns</dt><dd>An unordered map containing vertex codes and their respective flow values. @complexity O(C), where C is the number of cities. </dd></dl>

</div>
</div>
<a id="a9517ce860591b3c2e6453dfa282b55b2" name="a9517ce860591b3c2e6453dfa282b55b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9517ce860591b3c2e6453dfa282b55b2">&#9670;&#160;</a></span>getSuperSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vertex.html">Vertex</a> * NetworkController::getSuperSink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a super sink vertex that connects all sinks to it with edge capacity INF. </p>
<p>Ensures the existence of a vertex representing the super sink in the network. If it doesn't exist, it creates one with the code "SuperSink" and connects it to all cities in the network with pipes having capacities equal to each city's demand.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the super sink vertex. @complexity O(C), where C is the number of cities, due to the creation of edges from each city to the super sink. </dd></dl>

</div>
</div>
<a id="af46761ae0837190c2cc46a3a89fb3de7" name="af46761ae0837190c2cc46a3a89fb3de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46761ae0837190c2cc46a3a89fb3de7">&#9670;&#160;</a></span>getSuperSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vertex.html">Vertex</a> * NetworkController::getSuperSource </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a super source vertex that connects all sources to it with edge capacity INF. </p>
<p>Creates a super source vertex if it doesn't already exist in the network. It connects this super source vertex to all water reservoirs by creating pipes from the super source to each reservoir with capacities equal to their maximum delivery.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the super source vertex. @complexity O(R), where R is the number of reservoirs, due to the creation of edges from the super source to each reservoir. </dd></dl>

</div>
</div>
<a id="a5b233f36990e2cba20af91739ab4188b" name="a5b233f36990e2cba20af91739ab4188b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b233f36990e2cba20af91739ab4188b">&#9670;&#160;</a></span>getVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vertex.html">Vertex</a> * NetworkController::getVertex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a vertex from the graph by its identifier. </p>
<p>Uses the findVertex method of the network object to search for the vertex with the specified ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The identifier of the vertex to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the vertex if found, nullptr otherwise. @complexity O(1), assuming a hash map or similar data structure is used for efficient lookup. </dd></dl>

</div>
</div>
<a id="afd67674c6fe7831a02ddebed6ef0962e" name="afd67674c6fe7831a02ddebed6ef0962e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd67674c6fe7831a02ddebed6ef0962e">&#9670;&#160;</a></span>initializeNetwork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::initializeNetwork </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>small</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the network graph. </p>
<p>Sets up the network according to the specified mode, either small or large. If the small parameter is true, it calls parseDataSmall to parse the data for a small network, otherwise it calls parseData for a large network. After parsing the data, it applies the Edmonds-Karp algorithm to find the maximum flow in the network using edmondsKarp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">small</td><td>Flag indicating whether to initialize a small version of the network. @complexity O(V + E) for parseData / O(V + E) for parseDataSmall, where V is the number of vertices and E is the number of edges. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a911d450474ee64e37936ba17189db583" name="a911d450474ee64e37936ba17189db583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911d450474ee64e37936ba17189db583">&#9670;&#160;</a></span>parseData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::parseData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses data from files to initialize the network graph. </p>
<p>Reads data for cities, reservoirs, pumping stations, and pipes from the datasets. It calls individual functions for each data type and handles any exceptions that may occur during parsing. Finally, it prints a completion message. @complexity O(N), where N is the sum of lines in all data files. </p>

</div>
</div>
<a id="a2016e06885a75757fe09ad5d4109580b" name="a2016e06885a75757fe09ad5d4109580b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2016e06885a75757fe09ad5d4109580b">&#9670;&#160;</a></span>parseDataSmall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::parseDataSmall </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a small amount of data from files to initialize the network graph. </p>
<p>Reads data for cities, reservoirs, stations, and pipes from small-sized datasets. It calls individual functions for each data type and handles any exceptions that may occur during parsing. Finally, it prints a completion message. @complexity O(N), where N is the sum of lines in small data files. </p>

</div>
</div>
<a id="a5274e2d7054a384189406332ed8fc302" name="a5274e2d7054a384189406332ed8fc302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5274e2d7054a384189406332ed8fc302">&#9670;&#160;</a></span>readCities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::readCities </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads city data from files and adds city vertices to the graph. </p>
<p>Reads city data from a CSV file located at a specified path. It opens the file and reads each line, parsing information about each city such as name, ID, code, demand, and population. It then creates a <a class="el" href="class_city.html" title="Class representing a city vertex in the graph.">City</a> object with this information and adds it to the network. If the file cannot be opened, it throws an invalid_argument exception. @complexity O(C), where C is the number of cities. </p>

</div>
</div>
<a id="a5990ce7ee9d7d954fc930ac25928b487" name="a5990ce7ee9d7d954fc930ac25928b487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5990ce7ee9d7d954fc930ac25928b487">&#9670;&#160;</a></span>readCitiesSmall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::readCitiesSmall </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a small amount of city data from files and adds city vertices to the graph. </p>
<p>Reads city data from a CSV file located at a specific path. It opens the file and reads each line, parsing information about each city such as name, ID, code, demand, and population. It then creates a <a class="el" href="class_city.html" title="Class representing a city vertex in the graph.">City</a> object with this information and adds it to the network. If the file cannot be opened, it prints an error message. @complexity O(C), where C is the number of cities. </p>

</div>
</div>
<a id="a20e9b3e10e489a2716b8174d9772013f" name="a20e9b3e10e489a2716b8174d9772013f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e9b3e10e489a2716b8174d9772013f">&#9670;&#160;</a></span>readPipes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::readPipes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads pipe data from files and adds pipes to connect vertices in the graph. </p>
<p>Reads pipe data from a CSV file specified by dataRoot. It opens the file and reads each line, parsing information about each pipe such as service points, capacity, and direction. It then adds edges to the network based on this information. If any endpoint of the pipe doesn't exist in the network, it throws an exception. @complexity O(P), where P is the number of pipes. </p>

</div>
</div>
<a id="af704aebfe404fc5430d2074ab15682fb" name="af704aebfe404fc5430d2074ab15682fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af704aebfe404fc5430d2074ab15682fb">&#9670;&#160;</a></span>readPipesSmall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::readPipesSmall </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a small amount of pipe data from files and adds pipes to connect vertices in the graph. </p>
<p>Reads pipe data for a small network from a CSV file. It iterates over each line of the file, extracts information about each pipe (such as service points, capacity, and direction), and adds edges to the network accordingly. If any endpoint of the pipe doesn't exist in the network, it throws an exception. @complexity O(E), where E is the number of pipes in the small dataset. </p>

</div>
</div>
<a id="a271abf1a9f0fb19db8a034c1a66d3178" name="a271abf1a9f0fb19db8a034c1a66d3178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271abf1a9f0fb19db8a034c1a66d3178">&#9670;&#160;</a></span>readPumpingStations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::readPumpingStations </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads pumping station data from files and adds pumping station vertices to the graph. </p>
<p>Reads pumping station data from a CSV file located at a specific path. It opens the file and reads each line, parsing information about each station, such as its ID and code. It then creates a <a class="el" href="class_pumping_station.html" title="Represents a pumping station vertex in a graph.">PumpingStation</a> object with this information and adds it to the network. If the file cannot be opened, it throws an invalid argument exception. @complexity O(P), where P is the number of pumping stations. </p>

</div>
</div>
<a id="af107057d276b2b6b33493a0909761725" name="af107057d276b2b6b33493a0909761725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af107057d276b2b6b33493a0909761725">&#9670;&#160;</a></span>readReservoirs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::readReservoirs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads reservoir data from files and adds reservoir vertices to the graph. </p>
<p>Reads reservoir data from a CSV file located at a specific path. It opens the file and reads each line, parsing information about each reservoir, such as its name, municipality, ID, code, and maximum delivery. It then creates a <a class="el" href="class_water_reservoir.html" title="Represents a water reservoir vertex in the network.">WaterReservoir</a> object with this information and adds it to the network. If the file cannot be opened, it throws an invalid argument exception. @complexity O(R), where R is the number of reservoirs. </p>

</div>
</div>
<a id="ad91437811c29e05a2e1c852cd8d7d79c" name="ad91437811c29e05a2e1c852cd8d7d79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91437811c29e05a2e1c852cd8d7d79c">&#9670;&#160;</a></span>readReservoirsSmall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::readReservoirsSmall </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a small amount of reservoir data from files and adds reservoir vertices to the graph. </p>
<p>Reads pumping station data from a CSV file located at a specific path. It opens the file and reads each line, parsing information about each station, such as its ID and code. It then creates a <a class="el" href="class_pumping_station.html" title="Represents a pumping station vertex in a graph.">PumpingStation</a> object with this information and adds it to the network. If the file cannot be opened, it throws an invalid argument exception. @complexity O(R), where R is the number of reservoirs in the small dataset. </p>

</div>
</div>
<a id="afcd6bcc261d916c0ba1ffd681f36c416" name="afcd6bcc261d916c0ba1ffd681f36c416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd6bcc261d916c0ba1ffd681f36c416">&#9670;&#160;</a></span>readStationsSmall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::readStationsSmall </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a small amount of pumping station data from files and adds pumping station vertices to the graph. </p>
<p>Reads station data from a CSV file located at a specific path. It opens the file and reads each line, parsing information about each station, such as its ID and code. It then creates a <a class="el" href="class_pumping_station.html" title="Represents a pumping station vertex in a graph.">PumpingStation</a> object with this information and adds it to the network. If the file cannot be opened, it prints an error message and returns. If a line has insufficient data or empty ID and code, it skips that line. @complexity O(P), where P is the number of pumping stations in the small dataset. </p>

</div>
</div>
<a id="a5b9e4151c670ce849efcdcb0c7c0aab4" name="a5b9e4151c670ce849efcdcb0c7c0aab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9e4151c670ce849efcdcb0c7c0aab4">&#9670;&#160;</a></span>saveCityData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::saveCityData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves city data to files. </p>
<p>Stores data about city flows in a text file named "max_flow_network.txt" located in the output directory. It first retrieves the super sink vertex to access incoming pipes. Then, it opens the output file and writes a header indicating the format of the data to be stored. For each incoming pipe, representing a city, it retrieves the city's code, demand, and flow, and writes this information to the file. If the file cannot be opened, it displays an error message. @complexity O(C), where C is the number of cities. </p>

</div>
</div>
<a id="a76e11da8f5a2b362d8d5b6a49871971f" name="a76e11da8f5a2b362d8d5b6a49871971f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e11da8f5a2b362d8d5b6a49871971f">&#9670;&#160;</a></span>testAndVisit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NetworkController::testAndVisit </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pipe.html">Pipe</a> *</td>          <td class="paramname"><span class="paramname"><em>pipe</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>dest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>residual</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests and visits vertices along a path to determine the residual flow. </p>
<p>Serves as a helper function within the BFS traversal process of the Edmonds-Karp algorithm, determining whether adjacent vertices should be visited based on residual capacity and visitation status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A queue of vertices to visit. </td></tr>
    <tr><td class="paramname">pipe</td><td>The pipe connecting the vertices. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination vertex. </td></tr>
    <tr><td class="paramname">residual</td><td>The residual flow. @complexity O(1), as the operation consists of conditional checks and queue manipulation, which are constant time operations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac5168629871a52c482123004704a4384" name="ac5168629871a52c482123004704a4384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5168629871a52c482123004704a4384">&#9670;&#160;</a></span>dataRoot</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string NetworkController::dataRoot</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Root directory containing data files </p>

</div>
</div>
<a id="a27713d324f3e08d08ccf7ad6ef3d9142" name="a27713d324f3e08d08ccf7ad6ef3d9142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27713d324f3e08d08ccf7ad6ef3d9142">&#9670;&#160;</a></span>maxFlowValid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NetworkController::maxFlowValid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag indicating whether maximum flow calculation is valid </p>

</div>
</div>
<a id="adde3b04107475aabb34b0dbaffc01dd3" name="adde3b04107475aabb34b0dbaffc01dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde3b04107475aabb34b0dbaffc01dd3">&#9670;&#160;</a></span>network</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> NetworkController::network</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_graph.html">Graph</a> representing the network </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/goncalomatias/Documents/GitHub/DA-Project-23-24/include/<a class="el" href="_network_controller_8h_source.html">NetworkController.h</a></li>
<li>/Users/goncalomatias/Documents/GitHub/DA-Project-23-24/src/<b>NetworkController.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
